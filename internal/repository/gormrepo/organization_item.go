package gormrepo

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/passwall/passwall-server/internal/domain"
	"github.com/passwall/passwall-server/internal/repository"
	uuid "github.com/satori/go.uuid"
	"gorm.io/gorm"
)

type organizationItemRepository struct {
	db *gorm.DB
}

// NewOrganizationItemRepository creates a new organization item repository
func NewOrganizationItemRepository(db *gorm.DB) repository.OrganizationItemRepository {
	return &organizationItemRepository{db: db}
}

func (r *organizationItemRepository) Create(ctx context.Context, item *domain.OrganizationItem) error {
	// Generate UUID if not set
	if item.UUID == uuid.Nil {
		item.UUID = uuid.NewV4()
	}

	// Note: support_id and revision are auto-generated by trigger

	return r.db.WithContext(ctx).Create(item).Error
}

func (r *organizationItemRepository) GetByID(ctx context.Context, id uint) (*domain.OrganizationItem, error) {
	var item domain.OrganizationItem
	err := r.db.WithContext(ctx).
		Preload("Organization").
		Preload("Collection").
		Preload("CreatedBy").
		Where("id = ? AND deleted_at IS NULL", id).
		First(&item).Error

	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, repository.ErrNotFound
		}
		return nil, err
	}
	return &item, nil
}

func (r *organizationItemRepository) GetByUUID(ctx context.Context, uuidStr string) (*domain.OrganizationItem, error) {
	var item domain.OrganizationItem
	err := r.db.WithContext(ctx).
		Preload("Organization").
		Preload("Collection").
		Preload("CreatedBy").
		Where("uuid = ? AND deleted_at IS NULL", uuidStr).
		First(&item).Error

	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, repository.ErrNotFound
		}
		return nil, err
	}
	return &item, nil
}

func (r *organizationItemRepository) GetBySupportID(ctx context.Context, supportID int64) (*domain.OrganizationItem, error) {
	var item domain.OrganizationItem
	err := r.db.WithContext(ctx).
		Preload("Organization").
		Preload("Collection").
		Preload("CreatedBy").
		Where("support_id = ? AND deleted_at IS NULL", supportID).
		First(&item).Error

	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, repository.ErrNotFound
		}
		return nil, err
	}
	return &item, nil
}

func (r *organizationItemRepository) ListByOrganization(ctx context.Context, filter repository.OrganizationItemFilter) ([]*domain.OrganizationItem, int64, error) {
	var items []*domain.OrganizationItem
	var total int64

	// Base query
	query := r.db.WithContext(ctx).Model(&domain.OrganizationItem{}).Where("deleted_at IS NULL")

	// Apply organization filter (required)
	query = query.Where("organization_id = ?", filter.OrganizationID)

	// Apply collection filter
	if filter.CollectionID != nil {
		query = query.Where("collection_id = ?", *filter.CollectionID)
	}

	// Apply item type filter
	if filter.ItemType != nil {
		query = query.Where("item_type = ?", *filter.ItemType)
	}

	// Apply favorite filter
	if filter.IsFavorite != nil {
		query = query.Where("is_favorite = ?", *filter.IsFavorite)
	}

	// Apply folder filter
	if filter.FolderID != nil {
		query = query.Where("folder_id = ?", *filter.FolderID)
	}

	// Apply auto-fill filter
	if filter.AutoFill != nil {
		query = query.Where("auto_fill = ?", *filter.AutoFill)
	}

	// Apply auto-login filter
	if filter.AutoLogin != nil {
		query = query.Where("auto_login = ?", *filter.AutoLogin)
	}

	// Search in metadata
	if filter.Search != "" {
		searchPattern := "%" + filter.Search + "%"
		query = query.Where(
			"metadata->>'name' ILIKE ? OR metadata->>'uri_hint' ILIKE ?",
			searchPattern,
			searchPattern,
		)
	}

	// Filter by tags
	if len(filter.Tags) > 0 {
		for _, tag := range filter.Tags {
			query = query.Where("metadata->'tags' @> ?", fmt.Sprintf(`["%s"]`, tag))
		}
	}

	// Count total
	if err := query.Count(&total).Error; err != nil {
		return nil, 0, err
	}

	// Pagination
	if filter.Page <= 0 {
		filter.Page = 1
	}
	if filter.PerPage <= 0 {
		filter.PerPage = 50
	}
	if filter.PerPage > 5000 {
		filter.PerPage = 5000
	}

	offset := (filter.Page - 1) * filter.PerPage
	query = query.Offset(offset).Limit(filter.PerPage)

	// Order by
	query = query.Order("created_at DESC")

	// Preload associations
	query = query.Preload("Collection").Preload("CreatedBy")

	// Execute query
	if err := query.Find(&items).Error; err != nil {
		return nil, 0, err
	}

	return items, total, nil
}

func (r *organizationItemRepository) ListByCollection(ctx context.Context, collectionID uint) ([]*domain.OrganizationItem, error) {
	var items []*domain.OrganizationItem
	err := r.db.WithContext(ctx).
		Preload("CreatedBy").
		Where("collection_id = ? AND deleted_at IS NULL", collectionID).
		Order("created_at DESC").
		Find(&items).Error

	if err != nil {
		return nil, err
	}
	return items, nil
}

func (r *organizationItemRepository) MoveItemsToCollection(ctx context.Context, fromCollectionID uint, toCollectionID uint) error {
	return r.db.WithContext(ctx).
		Model(&domain.OrganizationItem{}).
		Where("collection_id = ? AND deleted_at IS NULL", fromCollectionID).
		Update("collection_id", toCollectionID).Error
}

func (r *organizationItemRepository) Update(ctx context.Context, item *domain.OrganizationItem) error {
	// Clear associations
	item.Organization = nil
	item.Collection = nil
	item.CreatedBy = nil

	// Note: revision is auto-incremented by trigger

	return r.db.WithContext(ctx).Save(item).Error
}

func (r *organizationItemRepository) Delete(ctx context.Context, id uint) error {
	// Hard delete
	return r.db.WithContext(ctx).Unscoped().Delete(&domain.OrganizationItem{}, id).Error
}

func (r *organizationItemRepository) SoftDelete(ctx context.Context, id uint) error {
	now := time.Now()
	return r.db.WithContext(ctx).
		Model(&domain.OrganizationItem{}).
		Where("id = ?", id).
		Update("deleted_at", now).Error
}

func (r *organizationItemRepository) HardDelete(ctx context.Context, id uint) error {
	return r.db.WithContext(ctx).Unscoped().Delete(&domain.OrganizationItem{}, id).Error
}
